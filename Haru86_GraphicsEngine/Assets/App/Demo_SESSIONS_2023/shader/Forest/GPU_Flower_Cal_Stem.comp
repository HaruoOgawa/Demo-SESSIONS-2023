R"(

#version 430

// 0 -> kernel CalStemBSplineCurveResult

// 1 -> kernel InitStemGrowth

// 2 -> kernel CalStemManage
// 3 -> kernel CalStemGrowth

uniform int _KernelIndex;

#define NUMTHRED_VAL 256

struct StemVertex{
    vec4 vertice;
    vec4 tangent;
    vec4 normal;
    vec4 bioNormal;
    int index;
};

//花の数など
struct StemManage{
    float stemLifeVal;
    float stemWaitTime;
    float signNum;
    int manageLifeCountFlag;
    int flowerCount;
    int flowerStartIndex;
    int leafCount;
    int leafStartIndex;
};

//花や茎を生成するための情報を載せる構造体
struct StemData{
    int resampleIndex;
    int resampleIndexInStem;
    vec4 position;
    vec4 tangent;
    vec4 normal;
    vec4 bioNormal;
    int renderFlag;
    float lifeTime;
    float flowerSize;
};

// 各花の生える基本の座標
struct StemBasePosition {
    vec4 position;
};

layout(std430,binding = 0) buffer stemResult_buffer
{
    StemVertex stemResult[];
} out_stemResult_buffer;

layout(std430,binding = 1) buffer stemVertex_buffer
{
    StemVertex stemVertex[];
} out_stemVertex_buffer;

layout(std430,binding = 2) buffer stemManage_buffer
{
    StemManage stemManage[];
} out_stemManage_buffer;

layout(std430,binding = 3) buffer stemBasePosition_buffer
{
    StemBasePosition stemBasePosition[];
} out_stemBasePosition_buffer;

//thread
layout(local_size_x=256,local_size_y=1,local_size_z=1) in;

uniform int _contPosArrayLength;
uniform vec4 _controlPoints0;
uniform vec4 _controlPoints1;
uniform vec4 _controlPoints2;
uniform vec4 _controlPoints3;
uniform vec4 _controlPoints4;
uniform vec4 _controlPoints5;
uniform float _knotMin;
uniform float _knotMax;
uniform float _tWidth;
uniform int _stemVertexCount;
uniform float _stemLength;
uniform float _DTime;
uniform float _stemGrowthRange;
uniform float _testLife;

//debug
//RWStructuredBuffer<float4x4> _write_stem_debug_bufer;

#define PI 3.14159265

float rand(vec2 st){
    return fract(
        sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123
    );
}

vec3 RandSpherePosition(vec2 st,float radiusVal){
    float r=radiusVal*(rand(st+vec2(0.123,0.456))*0.9+0.1);
    float a=2.0*PI*rand(st+vec2(0.963,0.741));
    return vec3(r*cos(a),0.0,r*sin(a));
}

float GetBasisFunctionFour(float u[10],int j,int k,float t){
    float w1=0.0;
    float w2=0.0;

    if(u[j]<t&&t<=u[j+1]){
        return 1.0;
    }else{
        return 0.0;
    }
    
}

float GetBasisFunctionThird(float u[10],int j,int k,float t){
    float w1=0.0;
    float w2=0.0;

        if(u[j]<t&&t<=u[j+1]){
            return 1.0;
        }else{
            return 0.0;
        }
}

float GetBasisFunctionSecond(float u[10],int j,int k,float t){
    float w1=0.0;
    float w2=0.0;

    if(k==0){
        if(u[j]<t&&t<=u[j+1]){
            return 1.0;
        }else{
            return 0.0;
        }
    }else{
        if(u[j+k+1]-u[j+1]!=0.0){
            w1=GetBasisFunctionThird(u,j+1,k-1,t)*(u[j+k+1]-t)/(u[j+k+1]-u[j+1]);
        }

        if((u[j+k]-u[j])!=0.0){
            w2=GetBasisFunctionThird(u,j,k-1,t)*(t-u[j])/(u[j+k]-u[j]);
        }

        return w1+w2;
    }
    
}

float GetBasisFunction(float u[10],int j,int k,float t){
    float w1=0.0;
    float w2=0.0;

    if(k==0){
        if(u[j]<t&&t<=u[j+1]){
            return 1.0;
        }else{
            return 0.0;
        }
    }else{
        if(u[j+k+1]-u[j+1]!=0.0){
            w1=GetBasisFunctionSecond(u,j+1,k-1,t)*(u[j+k+1]-t)/(u[j+k+1]-u[j+1]);
        }

        if((u[j+k]-u[j])!=0.0){
            w2=GetBasisFunctionSecond(u,j,k-1,t)*(t-u[j])/(u[j+k]-u[j]);
        }

        return w1+w2;
    }
    
}

void Cal_BSplineCurve(inout vec3 S[64],vec4 controlPoints[6],float knotMin,float knotMax,float tWidth,uvec3  DID){
    int p=6;
    int n=3;
    int m=p+n+1;
 
    //GetKnotVector
    float u[10];
    int knotN=n+1;
    
    for(int i=0;i<m;i++){
        if(i>=0&&i<knotN){
            u[i]=knotMin;
        }else if(i>=knotN&&i<(m-knotN)){
            int knotWidth=m-knotN*2;
            float knotVal=(knotMax-knotMin)/float(knotWidth+1);
            knotVal=knotVal*float(i-knotN+1);
            u[i]=knotVal;
        }else if(i>=(m-knotN)&&i<m){
            u[i]=knotMax;
        }
    }
    
    float tDelta[64];
    int num=int((knotMax-knotMin)/tWidth);
    for(int i=0;i<num;i++){
        tDelta[i]=float(tWidth*i);
    }

    for(int i=0;i<64;i++){
        S[i]=vec3(0,0,0);
    }
    
    S[0]=controlPoints[0].xyz;
    
    for(int i=1;i<64;i++){
        for(int j=0;j<p;j++){
            float b=GetBasisFunction(u,j,n,tDelta[i]);
            S[i]=S[i]+controlPoints[j].xyz*b;
        }
    }
}

void CalStemBSplineCurveResult(uvec3  DID){
    vec3 stemBasePosition[64];
    for(int i=0;i<64;i++){
        stemBasePosition[i]=vec3(0,0,0);
    }

    vec3 resampleControlPoints[6];
    int stemGroupID=int(floor(int(DID.x)/_stemVertexCount));
    int idInMyStem=int(DID.x)-stemGroupID*_stemVertexCount;
    
    vec4 cp[6];
    //vec4 cp[6]=_controlPoints;
    cp[0]=_controlPoints0;
    cp[1]=_controlPoints1;
    cp[2]=_controlPoints2;
    cp[3]=_controlPoints3;
    cp[4]=_controlPoints4;
    cp[5]=_controlPoints5;

    float cpPower=1.0;
    for(int i=0;i<6;i++){
        cp[i].xyz+=((i==5)? 0 : 1)*cpPower*vec3(rand(vec2(float(stemGroupID),0.123+float(i)))*2.0-1.0,
                            rand(vec2(float(stemGroupID),0.456+float(i)))*2.0-1.0,
                            rand(vec2(float(stemGroupID),0.789+float(i)))*2.0-1.0
                            );
    }

    Cal_BSplineCurve(stemBasePosition,cp,_knotMin,_knotMax,_tWidth,DID);
    
    StemVertex stemO;
    stemO.vertice=vec4(stemBasePosition[idInMyStem],1.0);
    stemO.tangent=vec4(0.0,0.0,0.0,0.0);
    stemO.normal=vec4(0.0,0.0,0.0,0.0);
    stemO.bioNormal=vec4(0.0,0.0,0.0,0.0);

    if(idInMyStem>0&&idInMyStem<64-1){
        vec3 stemTangent=normalize(stemBasePosition[idInMyStem+1]-stemBasePosition[idInMyStem-1]);
        vec3 stemNormal=normalize(cross(stemTangent,vec3(1,0,0)));
        vec3 stemBioNormal=normalize(cross(stemTangent,stemNormal));

        stemO.tangent=vec4(stemTangent,0.0);
        stemO.normal=vec4(stemNormal,0.0);
        stemO.bioNormal=vec4(stemBioNormal,0.0);

    }

    stemO.index=idInMyStem;

    out_stemResult_buffer.stemResult[int(DID.x)]=stemO;
}

void InitStemGrowth(uvec3  DID){
    int stemGroupID=int(floor(int(DID.x)/_stemVertexCount));
    int idInMyStem=int(DID.x)-stemGroupID*_stemVertexCount;
    StemManage sManege=out_stemManage_buffer.stemManage[stemGroupID];
    float life=sManege.stemLifeVal;

    life=_testLife;

    int resampleStemNodeID=int(floor(idInMyStem*life));
    resampleStemNodeID=stemGroupID*_stemVertexCount+resampleStemNodeID;

    StemVertex result=out_stemResult_buffer.stemResult[resampleStemNodeID];

    StemVertex stemO;
    vec3 BasePosition = out_stemBasePosition_buffer.stemBasePosition[stemGroupID].position.xyz;
    stemO.vertice=result.vertice+vec4(BasePosition,0.0);
    stemO.tangent=result.tangent;
    stemO.normal=result.normal;
    stemO.bioNormal=result.bioNormal;
    stemO.index=result.index;

    out_stemVertex_buffer.stemVertex[int(DID.x)]=stemO;
}

void CalStemManage(uvec3  DID)
     {
    StemManage sManege=out_stemManage_buffer.stemManage[int(DID.x)];
    float life=sManege.stemLifeVal;
    float waitTime=sManege.stemWaitTime;
    //_DTime*=0.2;
    
    if(sManege.manageLifeCountFlag==1){
        sManege.stemLifeVal=life+sManege.signNum*_DTime*0.2;
        
        if(life<0.0){
            sManege.manageLifeCountFlag=0;
            sManege.signNum=-sManege.signNum;
            sManege.stemWaitTime=rand(vec2(int(DID.x),0.123))*2.0+1.0;
            sManege.stemLifeVal=0.0;
            out_stemBasePosition_buffer.stemBasePosition[int(DID.x)].position.xyz=RandSpherePosition(vec2(int(DID.x),_DTime*0.2),_stemGrowthRange);
        }

        if(life>1.0){
            sManege.manageLifeCountFlag=0;
            sManege.signNum=-sManege.signNum;
            sManege.stemWaitTime=rand(vec2(int(DID.x),0.123))*7.0+3.0;
            sManege.stemLifeVal=1.0;
        }

    }else{
        sManege.stemWaitTime=waitTime-_DTime*0.2;
        if(waitTime<0.0){
            sManege.manageLifeCountFlag=1;
            sManege.stemWaitTime=0.0;
        }
    }

    out_stemManage_buffer.stemManage[int(DID.x)]=sManege;
}

void CalStemGrowth(uvec3  DID)
{
    int stemGroupID=int(floor(int(DID.x)/_stemVertexCount));
    int idInMyStem=int(DID.x)-stemGroupID*_stemVertexCount;
    StemManage sManege=out_stemManage_buffer.stemManage[stemGroupID];
    float life=sManege.stemLifeVal;

    int resampleStemNodeID=int(floor(idInMyStem*life));
    resampleStemNodeID=stemGroupID*_stemVertexCount+resampleStemNodeID;

    StemVertex result=out_stemResult_buffer.stemResult[resampleStemNodeID];

    StemVertex stemO;
    stemO.vertice=result.vertice+vec4(out_stemBasePosition_buffer.stemBasePosition[stemGroupID].position.xyz,0.0);
    stemO.tangent=result.tangent;
    stemO.normal=result.normal;
    stemO.bioNormal=result.bioNormal;
    stemO.index=result.index;

    out_stemVertex_buffer.stemVertex[int(DID.x)]=stemO;
}

// 0 -> kernel CalStemBSplineCurveResult

// 1 -> kernel InitStemGrowth

// 2 -> kernel CalStemManage
// 3 -> kernel CalStemGrowth

void main(){
    uvec3  DID=gl_GlobalInvocationID;

    if(_KernelIndex == 0)
    {
         CalStemBSplineCurveResult(DID);
    }
    else if(_KernelIndex == 1)
    {
        InitStemGrowth(DID);
    }
    else if(_KernelIndex == 2)
    {
        CalStemManage(DID);
    }
    else if(_KernelIndex == 3)
    {
        CalStemGrowth(DID);
    }
}

)"